## ADR 0002: Шарова Архітектура Моноліту


### 1. Контекст
Нам потрібна чітка структура коду всередині нашого модульного моноліту, щоб уникнути "спагеті-коду". Ми повинні визначити, де знаходиться логіка API, де бізнес-логіка, а де логіка домену.

### 2. Рішення
Ми приймаємо класичну 3-шарову архітектуру (Layers): `api/`, `service/`, `domain/`.

* **`api/` (або `routes/`, `controllers/`)**
    * **Що робить:** Приймає HTTP-запити, валідує вхідні дані (DTOs), викликає `service/` та повертає HTTP-відповіді (JSON або помилки).
    * **Не робить:** Не містить бізнес-логіки, не ходить напряму в БД.

* **`service/` (або `use-cases/`)**
    * **Що робить:** Містить всю бізнес-логіку. Координує дії, викликає моделі домену, спілкується зі сховищем (БД).
    * **Не робить:** Не знає про HTTP.

* **`domain/`**
    * **Що робить:** Містить наші моделі (класи `User`, `Product`) та їхні бізнес-правила (інваріанти).
    * **Не робить:** Не знає ні про API, ні про сервіси.

### 3. Напрямок залежностей
Залежності йдуть **зверху вниз**:
`api/` -> залежить від -> `service/` -> залежить від -> `domain/`

* **Заборонено:** `domain/` не може імпортувати `service/`. `service/` не може імпортувати `api/`.